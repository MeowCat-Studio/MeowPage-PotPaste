        <!DOCTYPE html>
        <html>
        <head>
        <title># 适配多人联机的mod</title>
        <meta charset="utf-8" />
        <style type="text/css">
                html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{margin:0;padding:0;border:0}body{font-family:Helvetica,arial,freesans,clean,sans-serif;font-size:14px;line-height:1.6;color:#333;background-color:#fff;padding:20px;max-width:960px;margin:0 auto}body>*:first-child{margin-top:0 !important}body>*:last-child{margin-bottom:0 !important}p,blockquote,ul,ol,dl,table,pre{margin:15px 0}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:antialiased}h1 tt,h1 code,h2 tt,h2 code,h3 tt,h3 code,h4 tt,h4 code,h5 tt,h5 code,h6 tt,h6 code{font-size:inherit}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{color:#777;font-size:14px}body>h2:first-child,body>h1:first-child,body>h1:first-child+h2,body>h3:first-child,body>h4:first-child,body>h5:first-child,body>h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1+p,h2+p,h3+p,h4+p,h5+p,h6+p{margin-top:10px}a{color:#4183c4;text-decoration:none}a:hover{text-decoration:underline}ul,ol{padding-left:30px}ul li>:first-child,ol li>:first-child,ul li ul:first-of-type,ol li ol:first-of-type,ul li ol:first-of-type,ol li ul:first-of-type{margin-top:0}ul ul,ul ol,ol ol,ol ul{margin-bottom:0}dl{padding:0}dl dt{font-size:14px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt>:first-child{margin-top:0}dl dt>:last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd>:first-child{margin-top:0}dl dd>:last-child{margin-bottom:0}pre,code,tt{font-size:12px;font-family:Consolas,"Liberation Mono",Courier,monospace}code,tt{margin:0;padding:0;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px}pre>code{margin:0;padding:0;white-space:pre;border:0;background:transparent}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:0}blockquote{border-left:4px solid #DDD;padding:0 15px;color:#777}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}hr{clear:both;margin:15px 0;height:0;overflow:hidden;border:0;background:transparent;border-bottom:4px solid #ddd;padding:0}table th{font-weight:bold}table th,table td{border:1px solid #ccc;padding:6px 13px}table tr{border-top:1px solid #ccc;background-color:#fff}table tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%}
        </style>
        </head>
        <body>
        <h1>适配多人联机的mod</h1>
<h5>声明（Декларация）</h5>
<p>为了声明您的mod支持多人游戏，您需要在 <code>launcher.js</code>中的<code>Launch(...)</code>之前调用<code>ConfigureMultiplayer(configuration)</code>方法。调用此方法时，您可以指定模组名称和模组的版本参数，这些参数将用于识别网络游戏中的mod。如果未指定任何参数，则将从<code>mod.info</code>获取。此外，如果存在<code>isClientOnly: true</code>参数，则该mod将被声明为纯粹的客户端，客户端mod不应影响整个世界，并且在连接服务器时也不会与服务器同步（例如：MiniMap，Recipe Viewer，WAILA）。</p>
<pre><code>ConfigureMultiplayer({
    name: "readable unique name", //mod的唯一网络名称
    version: "version", // mod的版本
    isClientOnly: true/false // 是否为存粹的客户端模组
});
</code></pre>
<h5>多人模组的基础概念（Общие понятия）</h5>
<p>为了使mod在多人游戏中正常工作，mod代码必须分为客户端和服务端两部分，除了网络数据包和网络实体的事件外，它们不会以任何方式相互交互。这意味着mod的客户端无法使用服务端的变量，函数等，反之亦然。</p>
<p>服务端应负责所有逻辑并与世界配合工作，而客户端则应处理来自服务器的数据并向服务器发送自定义事件来负责玩家可视的部分。</p>
<p>为了实现多人联机，IC提供的API和您使用的库必须已经适配多人联机。</p>
<p>如果您进入您自己的世界（即您为主机），则服务端和与其连接的客户端将在同一设备上启动。连接到他人的世界时（即您非主机），将在您的设备上启动客户端，并连接到主机上运行的服务器。</p>
<h5>网络数据包传输与处理（Передача и обработка сетевых пакетов）</h5>
<p>基本的网络功能基于从客户端到服务器或服务器到客户端的命名数据包的传输。 要接受具有特定名称的服务器或客户端的数据包，您可以注册一个事件，该事件将在每次使用相应名称的数据包到达时被触发。</p>
<pre><code>// 数据包到达客户端时将触发该事件 testMod.serverMessage
Network.addClientPacket("testMod.serverMessage", function(packetData) {
    // 数据包的形式 {sender: ..., text: ...}
    Game.message("[" + packetData.sender + "] " + packetData.text);
});

// 向所有玩家发送数据的函数
function sendMessageToAll(sender, text) {
    // 发送数据给所有客户端
    Network.sendToAllClients("testMod.serverMessage", {
        sender: sender,
        text: text
    });
}
</code></pre>
<p>同样，您可以将数据包从客户端发送到服务器。</p>
<pre><code>// 服务器接收到来自客户端的名为testMod.clientMessage的事件
Network.addServerPacket("testMod.clientMessage", function(client, data)) {
    // 向发件人发送消息
    sendMessageToAll(client.getPlayerUid(), data.text);
});

// 客户端上的函数，将消息发送到服务器，然后服务器将该消息发送到所有玩家
function sendMessageFromClient(message) {
    // 从客户端向服务器发送数据包
    Network.sendToServer("testMod.clientMessage", {text: message});
}
</code></pre>
<p>在最后一个示例中，服务器在接收到数据包时同时接收到client参数，它可以用来获取玩家实体(<code>client.getPlayerUid()</code>)。 此外，它还允许您将数据包发送到特定客户端，而不是一次向所有客户端发送数据包。 要通过playerUid获得客户端，请使用<code>Network.getClientForPlayer(playerUid)</code>。</p>
<pre><code>// 注册木棍的使用函数
Item.registerUseFunctionForID(280, function(coords, item, block, player) {
    // 获取使用木棍的玩家的客户端接口
    var client = Network.getClientForPlayer(player);
    // 检查客户端是否存在
    if (client != null) {
        // 向该客户端发送数据
        client.send("testMod.serverMessage", {
            sender: "server debug", // 发送方 "server debug"
            text: "you just used stick!" // 只能是文本
        });
    }
});
</code></pre>
<h5>转换方块和物品的ID</h5>
<p>（注：本文中“ID”一词若无标注均指数字ID）
相同字符串ID的方块或物品的数字ID在客户端和服务器上可能会有所不同。 Inner Core会自动同步数字ID。 但是，如果使用数据包以数字形式传输它们，则它们将可能对应不同的方块或物品，并且必须手动进行转换。</p>
<p>由于有许多客户端，并且只有一台服务器，因此转换发生在客户端，为此有函数<code>Network.serverToLocalId(id)</code> 和 <code>Network.localToServerId(id)</code>,将服务器ID与客户端ID互相转换。</p>
<p>一个例子：</p>
<pre><code>// 从服务器传到客户端的数据包，其中包含有关物品的信息（例子中我们仅传输ID和data）
Network.addClientPacket("testMod.useItemInfo", function() {
    // 我们将打印以下信息：首先是服务器发送给我们的ID，然后是该物品在客户端上具有的ID，为确认这与客户端上的物品相同，我们将通过客户端ID获得其名称
    var localId = Network.serverToLocalId(packetData.id);
    Game.message("you just used item: server=" + packetData.id + " client=" + localId + " name=" + Item.getName(localId, packetData.data));
});

// 物品被使用的服务器事件
Callback.addCallback("ItemUse", function(coords, item, block, isExternal, player) {
    var client = Network.getClientForPlayer(player);
    if (client != null) {
        // 发送包含物品信息的数据包，由于该事件是基于服务器的，因此这将是该物品的服务器ID
        client.send("testMod.useItemInfo", {id: item.id, data: item.data});
    }
});
</code></pre>
<p>为了在实践中测试此示例，您需要两个设备，因为在同一设备上运行的一对客户端和服务器将具有相同的ID。 要在两个设备上强制使用不同的ID，您可以尝试更改innercore/mods/.staticid文件。</p>
<h5>适配方块实体</h5>
<p>方块实体的主要逻辑在服务器运行。但是，您可以为客户端声明一个单独的原型。根据此原型，将为附近有 具有init、tick和destroy事件的方块实体 的客户端创建一个实例，并允许您添加视觉组件。</p>
<p>由于方块实体先前使用的旧容器不支持多人游戏，因此，为了让方块实体支持多人游戏，需要使用新的容器类型-ItemContainer。新的容器类型与旧的兼容。</p>
<p>以下是支持多人游戏的方块实体原型的文档，此处未列出的事件均会在服务器端被触发。</p>
<pre><code>{
	// 服务器端原型
	
	useNetworkItemContainer: true, // 允许使用支持多人游戏的容器
	
	defaultValues: {
        // 初始化存储的数据
	},

    // 初始化方块实体
	init: function() {
	    // 服务器方块实体提供以下属性:
	    // this.x, this.y, this.z, this.dimension - 坐标和维度
	    // this.data - 所有存储的值
	    // this.container - 对象 ItemContainer
	    // this.blockSource - 一个BlockSource对象，用于访问给定方块实体所在的位置（BlockSource类用途未知？）
	    // this.networkData - SyncedNetworkData对象，同步的数据可用于所有客户端
	    // this.networkEntity - 表示此方块实体所基于的网络实体的NetworkEntity对象（仅用于高级操作，通常不需要）
	    
	    // 发送数据
	    // this.sendPacket("eventName", data) - 将包发送到此方块实体的所有客户端实例
	},
    
    // 此事件在服务端被触发，并返回点击时打开的界面名称
	getScreenName: function(player, coords) {
        return "someName";
    },

    // 此事件在客户端被触发，由传入的名称（即由getScreenName方法返回的名称）返回要打开的窗口
    getScreenByName: function(screenName) {
        return someGuiWindow;
    },

	client: {
		// прототип экземпляра клиентского Tile Entity, экземпляр создается на каждого клиента, каждый раз, когда Tile Entity становится видно на стороне клиента и уничтожается каждый раз, когда его становится не видно.
		
		// вызывается при создании экземпляра 
		load: function() {
    	    // Внутри клиентского Tile Entity доступны следующие поля:
    	    // this.x, this.y, this.z, this.dimension - координаты и измерение
    	    // this.networkData - объект SyncedNetworkData синхронизированые данные, доступные всем клиентам
    	    // this.networkEntity - объект NetworkEntity, представляющий сетевую сущность, на основе которого работает данный Tile Entity, нужен только для продвинутых операций, обычно не требуется
			
			// контейнер и доступ к миру не доступны на стороне клиента
			
			// Сетевые методы
	        // this.sendPacket("eventName", data) - отправляет пакет серверному экземпляру Tile Entity
		},

        // вызывается при уничтожении экземпляра
		unload: function() {

		},

        // вызывается каждый тик на локальном потоке, стоит учесть, нагрузки на локальном потоке больше сказываются на производительности
		tick: function() {
			
		},

		events: {
			// события, принимающие пакеты на стороне клиента, в данном случае this будет клиентским экземпляром, получившим этот пакет
			packetName: function(packetData, packetExtra) {

			}
		},

		containerEvents: {
			// события клиентского экземпляра контейнера, this не определен
			// эти события предназначены для редактирования содержимого окна
			eventName: function(container, window, windowContent, eventData) {
				// window и windowContent могут быть null
				// Чтобы отправить данные на сервер container.sendEvent("eventName", someData)
			}
		}
	},

	events: {
		// события, принимающие пакеты на стороне сервера, в данном случае this - серверный экземпляр, получивший пакет 
		packetName: function(packetData, packetExtra, connectedClient) {
			// доступный только здесь метод, отправляет пакет конкретному клиенту: this.sendResponse("packetName", someData)
		}
	},

	containerEvents: {
		// события контейнера на стороне сервера, в данном случае this - серверный экземпляр, получивший пакет 

		eventName: function(eventData, connectedClient) {
			// доступный только здесь метод: this.container.sendResponseEvent("eventName", someData)
		}
	}
}
</code></pre>
<p>Рассмотрим несколько примеров, начиная с самого простого. В примерах будет отсутствовать объявление окна интерфейса, так как изменений в этой области не требуется, переменная, содержащая его, будет называться <code>guiExample</code>.</p>
<p>Пример простейшего Tile Entity с интерфейсом и базовой логикой контейнера.</p>
<pre><code>{
    useNetworkItemContainer: true, // использовать сетевой контейнер
    
    getScreenName: function(player, coords) {
        // мы имеем только один вариант интерфейса, назовем его "main"
        return "main";
    },

    getScreenByName: function(screenName) {
        // мы имеем только интерфейс с именем "main"
        return screenName == "main" ? guiExample : null;
        // кроме того возможен вариант без проверки имени:
        return guiExample;
    },
    
    tick: function() {
        // в серверном тике произведем базовую логику над контейнером:
        if (World.getThreadTime() % 20 == 0) {
            var slot = this.container.getSlot("someSlot");
            if (slot.id == 264) {
                // применять изменения слота нужно через setSlot, чтобы контейнер зарегистрировал их, просто изменение полей объекта (slot.count--) не будет считаться
                this.container.setSlot("someSlot", slot.id, slot.count - 1, slot.data, slot.extra);
                // валидация слота: если количество равно 0, очистить слот
                this.container.validateSlot("someSlot");
                // тут можно произвести какую то другую серверную логику
            }
        }
        // отправить все изменения контейнера клиентам, чтобы они отобразить актуальное содержимое, данная функция отправляет только измененные слоты и значения, что происходит быстро, потому ее можно вызывать в конце каждого тика, если в нем могли произойти изменения на стороне сервера
        this.container.sendChanges();
    }
}
</code></pre>
<p>Теперь рассмотрим использование сетевых событий Tile Entity. Следующий пример демонстрирует использование прототипа клиента и сетевых событий для создания анимаций из частиц и является продолжением прошлого (будут показаны только места, которые надо дополнить).</p>
<pre><code>{
    ...
    client: {
        // добавим прототип клиента, который будет отвечать за анимации
        events: {
            // событие, принимающее пакет animateParticles
            animateParticles: function(packetData) {
                // создать частицы огня в количестве packetData.power
                for (var i = 0; i &lt; packetData.power; i++) {
                    Particles.addParticle(7, this.x + .5, this.y + .5, this.z + .5, Math.random() - .5, Math.random() - .5, Math.random() - .5, 0);
                }
            }
        }
    }
    
    tick: function() {
        ...
        if (slot.id == 264) {
            ...
            // при успешной операции отправить событие анимации всем клиентам
            this.sendPacket("animateParticles", {power: 100}); 
        }
        ...
    }
}
</code></pre>
<h5>Тик игрока</h5>
<p>По скольку многие операции требуется производить для каждого игрока отдельно, введено дополнительное событие <code>ServerPlayerTick</code>. Это событие вызывается на стороне сервера каждый тик для каждого игрока. Далее идет пример добавления события:</p>
<pre><code>Callback.addCallback("ServerPlayerTick", function(playerUid, isPlayerDead) {
    // playerUid - сущность игрока
    // isPlayerDead - дополнительный параметр - мертв ли данный игрок
    var client = Network.getClientForPlayer(playerUid);
    if (client != null) {
        // что то сделать
    }
});
</code></pre>
<p>Кроме этого существует событие тика клиента, которое вызывается каждый тик клиентского потока - <code>LocalTick</code>. Все клиентские действия тика должны происходить в нем, в частности пользовательским движением игрока.</p>
<pre><code>Callback.addCallback("LocalTick", function() {
    // локального игрока можно получить через Player.get()
});
</code></pre>
<h5>Броня</h5>
<p>По скольку старые методы регистрации событий брони не подходили для мультиплеера, добавлены новые функции регистрации, которые приведены далее.</p>
<pre><code>Armor.registerOnTickListener(id, function(item, slot, player) {
    // данное событие вызывается каждый тик для каждого игрока, на которого надета эта броня
    // это событие может возвращать объект вида {id: , count: , data: , extra: }, чтобы изменить предмет брони, если ничего не возвращается, то броня изменена не будет
});
</code></pre>
<pre><code>Armor.registerOnHurtListener(id, function(item, slot, player, value, type, attacker, bool1, bool2) {
    // данное событие вызывается при нанесении урона игроку, на котором надета броня
    // это событие может возвращать объект вида {id: , count: , data: , extra: }, чтобы изменить предмет брони, если ничего не возвращается, то броня будет повреждена стандартным образом
});
</code></pre>
<pre><code>Armor.registerOnTakeOnListener(id, function(item, slot, player) {
    // данное событие вызывается когда игрок надевает броню или спавнится с ней
});
</code></pre>
<pre><code>Armor.registerOnTakeOffListener(id, function(item, slot, player) {
    // данное событие вызывается когда игрок снимает или заменяет этот предмет брони
});
</code></pre>

        <!-- Use style in style1-->
        </body>
        </html>
